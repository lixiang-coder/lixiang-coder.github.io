<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SSM框架 面试题</title>
    <link href="/2025/03/07/%E6%A1%86%E6%9E%B6/"/>
    <url>/2025/03/07/%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是面试常见的Spring的问题</p></blockquote><span id="more"></span><h1 id="框架篇面试题"><a href="#框架篇面试题" class="headerlink" title="框架篇面试题"></a>框架篇面试题</h1><p><img src="https://cdn.xzynet.top/SSM/image-20250307140115779.png" alt="image-20250307140115779"></p><p><strong>面试官</strong>：Spring框架中的单例bean是线程安全的吗？</p><p>不是线程安全的，当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑（成员方法），如果该处理逻辑中有对该单列状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。</p><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。</p><p>比如：我们通常在项目中使用的Spring bean都是不可可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“<strong>singleton</strong>”变更为“<strong>prototype</strong>”。</p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p><strong>面试官</strong>：什么是AOP</p><p>aop是面向切面编程，在spring中用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合，一般比如可以做为公共日志保存，事务处理等。</p><p><strong>面试官</strong>：你们项目中有没有使用到AOP</p><p>我们当时在后台管理系统中，就是使用aop来记录了系统的操作日志</p><p>主要思路是这样的，使用aop中的环绕通知+切点表达式，这个表达式就是要找到要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，比如类信息、方法信息、注解、请求方式等，获取到这些参数以后，保存到数据库。</p><p><strong>面试官</strong>：Spring中的事务是如何实现的</p><p>spring实现的事务本质就是aop完成，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><p><strong>面试官</strong>：Spring中事务失效的场景有哪些？</p><ol><li>如果方法上异常捕获处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，一定要抛出异常。</li><li>spring事务注解@Transactional上rollbackFor默认RuntimeException。如果是其他异常，就不会回滚事务。所以修改为Exception.class</li><li>如果方法上不是public修饰的，也会导致事务失效。spring为方法创建代理，添加事务前提条件是该方法为public</li></ol><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p><strong>面试官</strong>：Spring的bean的生命周期</p><p>首先会通过一个非常重要的类，叫做BeanDefinition获取bean的定义信息，这里面就封装了bean的所有信息，比如，类的全路径，是否是延迟加载，是否是单例等等这些信息。</p><p>在创建bean的时候，第一步是调用构造函数实例化bean</p><p>第二步是bean的依赖注入，比如一些set方法注入，像平时开发用的@Autowire都是这一步完成</p><p>第三步是处理Aware接口，如果某一个bean实现了Aware接口就会重写方法执行</p><p>第四步是bean的后置处理器BeanPostProcessor，这个是前置处理器</p><p>第五步是初始化方法，比如实现了接口InitializingBean或者自定义了方法init-method标签或@PostContruct</p><p>第六步是执行了bean的后置处理器BeanPostProcessor，主要是对bean进行增强，有可能在这里产生代理对象</p><p>最后一步是销毁bean。</p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p><strong>面试官</strong>：Spring中的循环引用</p><p>嗯，好的，我来解释一下</p><p>循环依赖：循环依赖其实就是循环引用，也就是两个或两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于A</p><p>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖</p><p>①一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</p><p>②二级缓存：缓存早期的bean对象（生命周期还没走完）</p><p>③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p><p><strong>面试官</strong>：那具体解决流程清楚吗？</p><p>第一，先实例A对象，同时会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第二，A在初始化的时候需要B对象，这个走B的创建的逻辑</p><p>第三，B实例化完成，也会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第四，B需要注入A，通过三级缓存中获取ObjectFactory来生成一个A的对象同时存入二级缓存，这个是有两种情况，一个是可能是A的普通对象，另外一个是A的代理对象，都可以让ObjectFactory来生产对应的对象，这也是三级缓存的关键</p><p>第五，B通过从通过二级缓存earlySingletonObjects  获得到A的对象后可以正常注入，B创建成功，存入一级缓存singletonObjects  </p><p>第六，回到A对象初始化，因为B对象已经创建完成，则可以直接注入B，A创建成功存入一次缓存singletonObjects </p><p>第七，二级缓存中的临时对象A清除 </p><p><strong>面试官</strong>：构造方法出现了循环依赖怎么解决？</p><p>由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入，可以使用@Lazy懒加载，什么时候需要对象再进行bean对象的创建。</p><h2 id="SpringMVC-执行流程"><a href="#SpringMVC-执行流程" class="headerlink" title="SpringMVC 执行流程"></a>SpringMVC 执行流程</h2><p><strong>面试官</strong>：SpringMVC的执行流程知道嘛</p><p>1、用户发送出请求到前端控制器DispatcherServlet，这是一个调度中心</p><p>2、DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。</p><p>3、HandlerMapping找到具体的处理器(可查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</p><p>4、DispatcherServlet调用HandlerAdapter（处理器适配器）。</p><p>5、HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）。</p><p>6、Controller执行完成返回ModelAndView对象。</p><p>7、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。</p><p>8、DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。</p><p>9、ViewReslover解析后返回具体View（视图）。</p><p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p><p>11、DispatcherServlet响应用户。</p><p>当然现在的开发，基本都是前后端分离的开发的，并没有视图这些，一般都是handler中使用Response直接结果返回</p><h2 id="Springboot自动配置"><a href="#Springboot自动配置" class="headerlink" title="Springboot自动配置"></a>Springboot自动配置</h2><p><strong>面试官</strong>：Springboot自动配置原理</p><p>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：</p><ul><li><p>@SpringBootConfiguration：启动类为配置类</p></li><li><p>@EnableAutoConfiguration：自动装配的核心注解</p></li><li><p>@ComponentScan：扫描启动类及其子包下的所有类</p></li></ul><p>@EnableAutoConfiguration通过<code>@Import</code>注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的Jar包的的classpath路径下<strong>META-INF&#x2F;spring.factories</strong>文件中的所配置的类的全类名。 </p><p>在这些配置类中所定义的Bean会根据条件注解所<strong>指定的条件来决定</strong>是否需要将其导入到Spring容器中。</p><p>一般条件判断会有像<code>@ConditionalOnClass</code>这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><p><strong>面试官</strong>：Spring 的常见注解有哪些？</p><p><img src="https://cdn.xzynet.top/SSM/image-20250307155237204.png" alt="image-20250307155237204"></p><p>第一类是：声明bean，有@Component、@Service、@Repository、@Controller</p><p>第二类是：依赖注入相关的，有@Autowired、@Qualifier、@Resourse</p><p>第三类是：标注Bean的作用域 @Scope</p><p>第四类是：spring配置相关的，比如@Configuration，@ComponentScan 和 @Bean </p><p>第五类是：跟aop相关做增强的注解  @Aspect，@Before，@After，@Around，@Pointcut</p><p><strong>面试官</strong>：SpringMVC常见的注解有哪些？</p><p><img src="https://cdn.xzynet.top/SSM/image-20250307155356913.png" alt="image-20250307155356913"></p><p>@RequestMapping：用于映射请求路径；</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象；</p><p>@RequestParam：指定请求参数的名称；</p><p>@PathViriable：从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数；</p><p>@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户端。</p><p>@RequestHeader：获取指定的请求头数据，还有像@PostMapping、@GetMapping这些。</p><p><strong>面试官</strong>：Springboot常见注解有哪些？</p><p><img src="https://cdn.xzynet.top/SSM/image-20250307155619187.png" alt="image-20250307155619187"></p><p>Spring Boot的核心注解是@SpringBootApplication，他由几个注解组成 : </p><ul><li>@SpringBootConfiguration： 组合了- @Configuration注解，实现配置文件的功能；</li><li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项</li><li>@ComponentScan：Spring组件扫描</li></ul><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p><strong>面试官</strong>：MyBatis执行流程</p><p>①读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件</p><p>②构造会话工厂SqlSessionFactory，一个项目只需要一个，单例的，一般由spring进行管理</p><p>③会话工厂创建SqlSession对象，这里面就含了执行SQL语句的所有方法</p><p>④操作数据库的接口，Executor执行器，同时负责查询缓存的维护</p><p>⑤Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</p><p>⑥输入参数映射</p><p>⑦输出结果映射</p><p><strong>面试官</strong>：Mybatis是否支持延迟加载？</p><p>是支持的</p><p>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</p><p>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载。</p><p>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false，默认是关闭的</p><p><strong>面试官</strong>：延迟加载的底层原理知道吗？</p><p>延迟加载在底层主要使用的CGLIB动态代理完成的</p><p>第一是，使用CGLIB创建目标对象的代理对象，这里的目标对象就是开启了延迟加载的mapper</p><p>第二个是当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，再执行sql查询</p><p>第三个是获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</p><p><strong>面试官</strong>：Mybatis的一级、二级缓存用过吗？</p><p>mybatis的一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</p><p>关于二级缓存需要单独开启</p><p>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储。</p><p>如果想要开启二级缓存需要在全局配置文件和映射文件中开启配置才行。</p><p><strong>面试官</strong>：Mybatis的二级缓存什么时候会清理缓存中的数据</p><p>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring boot</tag>
      
      <tag>SSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 面试题</title>
    <link href="/2025/03/07/MySQL-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/03/07/MySQL-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是面试常见的MySQL的问题</p></blockquote><span id="more"></span><h1 id="MySQL相关面试题"><a href="#MySQL相关面试题" class="headerlink" title="MySQL相关面试题"></a>MySQL相关面试题</h1><p><img src="https://cdn.xzynet.top/MySQL/image-20250307091522260.png" alt="image-20250307091522260"></p><h2 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h2><p>**面试官：**MySQL中，如何定位慢查询?</p><p>我们当时做压测的时候有的接口非常的慢，接口的响应时间超过了2秒以上，因为我们当时的系统部署了运维的监控系统Skywalking ，在展示的报表中可以看到是哪一个接口比较慢，并且可以分析这个接口哪部分比较慢，这里可以看到SQL的具体的执行时间，所以可以定位是哪个sql出了问题。</p><p>如果，项目中没有这种运维的监控系统，其实在MySQL中也提供了慢日志查询的功能，可以在MySQL的系统配置文件中开启这个慢日志的功能，并且也可以设置SQL执行超过多少时间来记录到一个日志文件中，我记得上一个项目配置的是2秒，只要SQL执行的时间超过了2秒就会记录到日志文件中，我们就可以在日志文件找到执行比较慢的SQL了。</p><p>**面试官：**那这个SQL语句执行很慢, 如何分析呢？</p><p>如果一条sql执行很慢，我们通常会使用mysql自动的执行计划explain来去查看这条sql的执行情况，比如在这里面可以通过key和key_len检查是否命中了索引，如果本身已经添加了索引，也可以判断索引是否有失效的情况。第二个，可以通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描，第三个可以通过extra建议来判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>**面试官：**了解过索引吗？（什么是索引）</p><p>索引在项目中还是比较常见的，它是帮助MySQL高效获取数据的数据结构，主要是用来提高数据检索的效率，降低数据库的IO成本，同时通过索引列对数据进行排序，降低数据排序的成本，也能降低了CPU的消耗。</p><p>**面试官：**索引的底层数据结构了解过嘛 ? </p><p>MySQL的默认的存储引擎InnoDB采用的B+树的数据结构来存储索引，选择B+树的主要的原因是：第一阶数更多，路径更短。第二个磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据。第三是B+树便于扫库和区间查询，叶子节点是一个双向链表。</p><p>**面试官：**B树和B+树的区别是什么呢？</p><p>第一：在B树中，非叶子节点和叶子节点都会存放数据，而B+树的所有的数据都会出现在叶子节点，在查询的时候，B+树查找效率更加稳定</p><p>第二：在进行范围查询的时候，B+树效率更高，因为B+树都在叶子节点存储，并且叶子节点是一个双向链表</p><p>**面试官：**索引创建原则有哪些？</p><p>这个情况有很多，不过都有一个大前提，就是表中的数据要超过10万以上，我们才会创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是像作为查询条件，排序字段或分组的字段这些。</p><p>还有就是，我们通常创建索引的时候都是使用复合索引来创建，一条sql的返回值，尽量使用覆盖索引，如果字段的区分度不高的话，我们也会把它放在组合索引后面的字段。</p><p>如果某一个字段的内容较长，我们会考虑使用前缀索引来使用，当然并不是所有的字段都要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢。</p><p>**面试官：**什么情况下索引会失效 ?</p><ol><li>索引在使用的时候没有遵循最左匹配法则，</li><li>模糊查询，如果%号在前面也会导致索引失效。</li><li>添加索引的字段上进行了运算操作或者类型转换也都会导致索引失效。</li><li>如果使用了复合索引，中间使用了范围查询，右边的条件索引也会失效。</li></ol><p>所以，通常情况下，想要判断出这条sql是否有索引失效的情况，可以使用explain执行计划来分析。</p><h2 id="聚集索引-二级索引"><a href="#聚集索引-二级索引" class="headerlink" title="聚集索引&amp;二级索引"></a>聚集索引&amp;二级索引</h2><p>**面试官：**什么是聚簇索引什么是非聚簇索引 ?</p><p>聚簇索引：数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个，一般情况下主键在作为聚簇索引的。</p><p>非聚簇索引：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个，一般我们自己定义的索引都是非聚簇索引。</p><h2 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h2><p>**面试官：**知道什么是回表查询嘛 ?</p><p>刚才介绍的聚簇索引和非聚簇索引是有关系的，回表的意思就是通过二级索引找到对应的主键值，然后再通过主键值找到聚集索引中所对应的整行数据，这个过程就是回表。</p><p>【<strong>备注</strong>：如果面试官直接问回表，则需要先介绍聚簇索引和非聚簇索引】</p><p>**面试官：**知道什么叫覆盖索引嘛 ? </p><p>覆盖索引是指select查询语句使用了索引，在返回的列，必须在索引中全部能够找到。</p><p>如果我们使用id查询，它会直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><p>如果按照二级索引查询数据的时候，返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *，尽量在返回的列中都包含添加索引的字段。</p><p>**面试官：**MYSQL超大分页怎么处理 ?</p><p>超大分页一般都是在数据量比较大时，我们使用了limit分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引 + 子查询来解决。</p><p>先分页查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了。</p><p>因为查询id的时候，走的覆盖索引，所以效率可以提升很多</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p>**面试官：**sql的优化的经验</p><ol><li>表的设计优化，数据类型的选择</li><li>索引优化，索引创建原则</li><li>sql语句优化，避免索引失效（不要使用select * …）</li><li>主从复制，读写分离，不让数据的写入，影响读操作</li><li>分库分表</li></ol><p>**面试官：**创建表的时候，你们是如何优化的呢？</p><p>我们主要参考的阿里出的那个开发手册《嵩山版》，就比如，在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint、int 、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型。</p><p>**面试官：**那在使用索引的时候，是如何优化呢？</p><p>【参考索引创建原则    进行描述】</p><p>**面试官：**你平时对sql语句做了哪些优化呢？</p><p>这个也有很多，比如SELECT语句务必指明字段名称，不要直接使用select * ，还有就是要注意SQL语句避免造成索引失效的写法；如果是聚合查询，尽量用union all代替union ，union会多一次去重过滤，效率比较低；如果是表关联的话，尽量使用innerjoin ，不要使用用left join right join，如必须使用 一定要以小表为驱动</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>**面试官：**事务的特性是什么？可以详细说一下吗？</p><p>ACID，分别指的是：原子性、一致性、隔离性、持久性；</p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性(Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p>我举个例子：A向B转账500，转账成功，A扣除500元，B增加500元，原子操作体现在要么都成功，要么都失败。</p><p>在转账的过程中，数据要一致，A扣除了500，B必须增加500。</p><p>在转账的过程中，隔离性体现在A像B转账，不能受其他事务干扰。</p><p>在转账的过程中，持久性体现在事务提交后，要把数据持久化。</p><p><strong>面试官</strong>：并发事务带来哪些问题？</p><p>我们在项目开发中，多个事务并发进行是经常发生的，并发也是必然的，有可能导致一些问题</p><ol><li><p>脏读：一个事务读到了另一个事务还没有提交的数据。比如当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p></li><li><p>不可重复读：一个事务先后读到同一条记录，但两个读取的数据不同。比如在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p></li><li><p>幻读：一个事务查询数据时，没有该数据，但是插入数据时，又发现这行数据已经存在，好像出现了“幻影”。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p></li></ol><p><strong>面试官</strong>：怎么解决这些问题呢？MySQL的默认隔离级别是？</p><p>解决方案是对事务进行隔离。MySQL支持四种隔离级别从低到高分别有：</p><ol><li>未提交读（read uncommitted）它解决不了刚才提出的所有问题，一般项目中也不用这个。</li><li>读已提交（read committed）它能解决脏读的问题的，但是解决不了不可重复读和幻读。</li><li>可重复读（repeatable read）它能解决脏读和不可重复读，但是解决不了幻读，这个也是mysql默认的隔离级别。</li><li>串行化（serializable）它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。</li></ol><p>注意：事务隔离级别越高，数据越安全，但是性能越低。所以，我们一般使用的都是mysql默认的隔离级别：可重复读</p><p><strong>面试官</strong>：undo log和redo log的区别</p><p>redo log日志记录的是数据页的物理变化，服务宕机可用来同步数据。</p><p>undo log 不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，就会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作。</p><p>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性。</p><p><strong>面试官</strong>：事务中的隔离性是如何保证的呢？(你解释一下MVCC)</p><p>事务的隔离性是由锁和mvcc实现的。</p><p>其中mvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是undo log日志，第三个是readView读视图。</p><p>隐藏字段是指：在mysql中给每个表都设置了隐藏字段，有一个是trx_id(事务id)，记录每一次操作的事务id，是自增的；另一个字段是roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址。</p><p>undo log主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表。</p><p>readView解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是rr隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用。</p><p><strong>面试官</strong>：MySQL主从同步原理</p><p><img src="https://cdn.xzynet.top/MySQL/image-20250307105717526.png" alt="image-20250307105717526"></p><p><strong>MySQL主从复制的核心就是二进制日志(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)</strong>，步骤如下：</p><p><img src="https://cdn.xzynet.top/MySQL/image-20250307105958566.png" alt="image-20250307105958566"></p><ol><li><p>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p></li><li><p>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p></li><li><p>从库重做中继日志中的事件，将改变反映它自己的数据</p></li></ol><p><strong>面试官</strong>：你们项目用过MySQL的分库分表吗？</p><p>嗯，因为我们都是微服务开发，每个微服务对应了一个数据库，是根据业务进行拆分的，这个其实就是垂直拆分。</p><p><strong>面试官</strong>：那你之前使用过水平分库吗？</p><p>这个是使用过的，我们当时的业务是(xxx)，一开始，我们也是单库，后来这个业务逐渐发展，业务量上来的很迅速，其中(xx)表已经存放了超过1000万的数据，我们做了很多优化也不好使，性能依然很慢，所以当时就使用了水平分库。</p><p>我们一开始先做了3台服务器对应了3个数据库，由于库多了，需要分片，我们当时采用的mycat来作为数据库的中间件。数据都是按照id（自增）取模的方式来存取的。</p><p>当然一开始的时候，那些旧数据，我们做了一些清洗的工作，我们也是按照id取模规则分别存储到了各个数据库中，好处就是可以让各个数据库分摊存储和读取的压力，解决了我们当时性能的问题</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 面试题</title>
    <link href="/2025/03/06/Redis-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/03/06/Redis-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是面试常见的Redis的问题</p></blockquote><span id="more"></span><h1 id="Redis相关面试题"><a href="#Redis相关面试题" class="headerlink" title="Redis相关面试题"></a>Redis相关面试题</h1><p><img src="https://cdn.xzynet.top/Redis/image-20250306202352914.png" alt="image-20250306202352914"></p><h2 id="缓存三剑客"><a href="#缓存三剑客" class="headerlink" title="缓存三剑客"></a>缓存三剑客</h2><p>面试官：什么是缓存穿透 ? 怎么解决 ?</p><p>缓存穿透是指查询一个一定<strong>不存在</strong>的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。这种情况大概率是遭到了攻击。</p><p>解决方案的话：</p><ol><li>缓存空对象（实现简单，维护方便），但是会有额外的内存消耗，可以设置合理的TTL，数据可能不一致</li><li>布隆过滤器</li></ol><p><strong>面试官</strong>：好的，你能介绍一下布隆过滤器吗？</p><p>布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是redisson实现的布隆过滤器。</p><p>它的底层主要是先去初始化一个比较大数组，里面存放的二进制0或1。在一开始都是0，当一个key来了之后经过3次hash计算，模于数组长度找到数据的下标然后把数组中原来的0改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。</p><p>当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。</p><p><strong>面试官</strong>：什么是缓存击穿 ? 怎么解决 ?</p><p>热点key问题：一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>解决方案有两种方式：</p><ol><li><p>互斥锁：当缓存失效时，线程1先获取一个互斥锁，查询数据库实现缓存重建，此时其他线程获取不到锁只能休眠再重试，最后缓存重建完成后，其他线程可以查到缓存。</p><img src="https://cdn.xzynet.top/Redis/1653328288627.png" alt="1653328288627" style="zoom: 50%;" /></li><li><p>逻辑过期：</p><img src="https://cdn.xzynet.top/Redis/1653328663897.png" alt="1653328663897" style="zoom: 50%;" /><ol><li>在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间</li><li>当查询的时候，从redis取出数据后判断时间是否过期</li><li>如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新</li></ol></li></ol><p>当然两种方案各有利弊：</p><ul><li><strong>强一致性</strong>：分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题</li><li><strong>高可用性</strong>：逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</li></ul><p><strong>面试官</strong>：什么是缓存雪崩 ? 怎么解决 ?</p><p>存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>与缓存击穿的区别：雪崩是很多key，击穿是某一个key缓存。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p>**面试官：**缓存的淘汰策略</p><ul><li>内存淘汰（redis会自动将一些不常用的缓存清理）</li><li>超时剔除（超过了TTL，会自动清理）</li><li>主动更新（主动删除缓存）</li></ul><h2 id="数据库缓存不一致"><a href="#数据库缓存不一致" class="headerlink" title="数据库缓存不一致"></a>数据库缓存不一致</h2><p><strong>面试官</strong>：redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）</p><p>性能高，数据不是强一致：我们当时是把商铺的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以，我们当时采用的延迟双删。</p><p>性能低，数据强一致：我们当时是把抢券的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致，我们当时采用的是redisson提供的读写锁来保证数据的同步。</p><p><strong>延迟双删：不能保证强一致，有脏数据的风险</strong></p><img src="https://cdn.xzynet.top/Redis/image-20250306211947678.png" alt="image-20250306211947678" style="zoom: 50%;" /><ol><li>不论先删除哪个都有脏数据的风险</li><li>所以要删除两次缓存就是为了降低脏数据的风险</li><li>延迟删除，因为数据库是主从模式，读写是分离的，延时一会让主节点把数据同步到从节点</li></ol><p><strong>分布式锁：保证强一致，但是性能低。</strong></p><img src="https://cdn.xzynet.top/Redis/image-20250306212723794.png" alt="image-20250306212723794" style="zoom: 33%;" /><p>共享锁：读锁readLock，加锁之后，其他线程可以共享读操作<br>排他锁：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作</p><p><strong>异步通知：保证数据最终一致性。</strong></p><img src="https://cdn.xzynet.top/Redis/image-20250306213423084.png" alt="image-20250306213423084" style="zoom:50%;" /><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><strong>面试官</strong>：redis做为缓存，数据的持久化是怎么做的？</p><p>在Redis中提供了两种数据持久化的方式：1、RDB  2、AOF</p><p><strong>面试官</strong>：这两种持久化方式有什么区别呢？</p><p>RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。</p><p>AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。</p><p><strong>面试官</strong>：这两种方式，哪种恢复的比较快呢？</p><p>RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令</p><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。</p><p><img src="https://cdn.xzynet.top/Redis/image-20250306215240617.png" alt="image-20250306215240617"></p><h2 id="数据过期策略"><a href="#数据过期策略" class="headerlink" title="数据过期策略"></a>数据过期策略</h2><p><strong>面试官</strong>：假如redis的key过期之后，会立即删除吗？</p><p>惰性删除：在设置该key过期时间后，我们不去管它，当使用key时，再检查其是否过期，如果过期就删掉它，反之返回该key。</p><p>定期删除：每隔一段时间，我们就对一些key进行检查，删除里面过期的key。</p><p>定期清理的两种模式：</p><ul><li>SLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf 的 <strong>hz</strong> 选项来调整这个次数</li><li>FAST模式执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms</li></ul><p>Redis的过期删除策略：<strong>惰性删除 + 定期删除</strong>两种策略进行配合使用。</p><h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><p><strong>面试官</strong>：假如缓存过多，内存是有限的，内存被占满了怎么办？</p><p>嗯，这个在redis中提供了很多种，默认是noeviction，不删除任何数据，内部不足直接报错</p><p>是可以在redis的配置文件中进行设置的，里面有两个非常重要的概念，一个是LRU，另外一个是LFU</p><p>LRU：<strong>最少最近使用</strong>，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p>LFU：<strong>最少频率使用</strong>。会统计每个key的访问频率，值越小淘汰优先级越高</p><p><strong>面试官</strong>：数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据 ?</p><p>可以使用 allkeys-lru （挑选最近最少使用的数据淘汰）淘汰策略，那留下来的都是经常访问的热点数据</p><p><strong>面试官</strong>：Redis的内存用完了会发生什么？</p><p>这个要看redis的数据淘汰策略是什么，如果是默认的配置，redis内存用完以后则直接报错。我们当时设置的 allkeys-lru 策略。把最近最常访问的数据留在缓存中。</p><h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><p><strong>面试官</strong>：Redis分布式锁如何实现 ? </p><p>嗯，在redis中提供了一个命令setnx(SET if not exists)</p><p>由于redis的单线程的，用了命令之后，只能有一个客户端对某一个key设置值，在没有过期或删除key的时候是其他客户端是不能设置这个key的</p><p><strong>面试官</strong>：好的，那你如何控制Redis实现分布式锁有效时长呢？</p><p>的确，redis的setnx指令不好控制这个问题，我们当时采用的redis的一个框架redisson实现的。</p><p>在redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在redisson中引入了一个看门狗机制，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了</p><p>还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户1持有锁的时候，客户2来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。</p><p><strong>面试官</strong>：好的，redisson实现的分布式锁是可重入的吗？</p><p>是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减一。在存储数据的时候采用的hash结构，大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数。</p><p><strong>面试官</strong>：redisson实现的分布式锁能解决主从一致性的问题吗？</p><p>这个是不能的，比如，当线程1加锁成功后，master节点数据会异步复制到slave节点，此时当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。</p><p>我们可以利用redisson提供的红锁来解决这个问题，它的主要作用是，不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁，并且要求在大多数redis节点上都成功创建锁，红锁中要求是redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。</p><p>但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁</p><p><strong>面试官</strong>：好的，如果业务非要保证数据的强一致性，这个该怎么解决呢？</p><p>redis本身就是支持高可用的，做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用zookeeper实现的分布式锁，它是可以保证强一致性的。</p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p><strong>面试官</strong>：Redis集群有哪些方案, 知道嘛 ? </p><p>在Redis中提供的集群方案总共有三种：主从复制、哨兵模式、Redis分片集群</p><p><strong>面试官</strong>：那你来介绍一下主从同步</p><p>是这样的，单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中。</p><p><strong>面试官</strong>：能说一下，主从同步数据的流程？</p><p>主从同步分为了两个阶段，一个是全量同步，一个是增量同步</p><p>全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：</p><img src="https://cdn.xzynet.top/Redis/image-20250306224142375.png" alt="image-20250306224142375" style="zoom:80%;" /><p>第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id和 offset 偏移量。</p><p>第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。</p><p>第三：在同时主节点会执行bgsave，生成rdb文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的rdb文件，这样就保持了一致</p><p>当然，如果在rdb生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步</p><p>增量同步流程</p><p><img src="https://cdn.xzynet.top/Redis/image-20250306224406936.png" alt="image-20250306224406936"></p><p>当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。</p><h2 id="Redis的高并发高可用"><a href="#Redis的高并发高可用" class="headerlink" title="Redis的高并发高可用"></a>Redis的高并发高可用</h2><p><strong>面试官</strong>：怎么保证Redis的高并发高可用</p><p>首先可以搭建主从集群，再加上使用redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复（对主从服务的监控、自动故障恢复、通知）；如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端，所以一般项目都会采用哨兵的模式来保证redis的高并发高可用。</p><p><strong>面试官</strong>：你们使用redis是单点还是集群，哪种集群</p><p>我们当时使用的是主从（1主1从）加哨兵。一般单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点。尽量不做分片集群。因为集群维护起来比较麻烦，并且集群之间的心跳检测和数据通信会消耗大量的网络带宽，也没有办法使用lua脚本和事务。</p><p><strong>面试官</strong>：redis集群脑裂，该怎么解决呢？</p><p>有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于redis master节点和redis salve节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个salve为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将old master降为salve，这时再从新master同步数据，这会导致old master中的大量数据丢失。</p><p>关于解决的话，我记得在redis的配置中可以设置：第一可以设置最少的salve节点个数，比如设置至少要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失。</p><h2 id="redis的分片集群"><a href="#redis的分片集群" class="headerlink" title="redis的分片集群"></a>redis的分片集群</h2><p><strong>面试官</strong>：redis的分片集群有什么作用？</p><p>分片集群主要解决的是，海量数据存储的问题，集群中有多个master，每个master保存不同数据，并且还可以给每个master设置多个slave节点，就可以继续增大集群的高并发能力。同时每个master之间通过ping监测彼此健康状态，就类似于哨兵模式了。当客户端请求可以访问集群任意节点，最终都会被转发到正确节点。</p><p><strong>面试官</strong>：Redis分片集群中数据是怎么存储和读取的？</p><p>Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑定了一定范围的哈希槽范围， key通过 CRC16 校验后对 16384 取模来决定放置哪个槽，通过槽找到对应的节点进行存储。</p><p>取值的逻辑是一样的</p><h2 id="Redis是单线程"><a href="#Redis是单线程" class="headerlink" title="Redis是单线程"></a>Redis是单线程</h2><p><strong>面试官</strong>：Redis是单线程的，但是为什么还那么快？</p><p>1、完全基于内存的，C语言编写</p><p>2、采用单线程，避免不必要的上下文切换可竞争条件</p><p>3、使用多路I&#x2F;O复用模型，非阻塞IO</p><p>例如：bgsave 和 bgrewriteaof  都是在<strong>后台</strong>执行操作，不影响主线程的正常使用，不会产生阻塞</p><p><strong>面试官</strong>：能解释一下I&#x2F;O多路复用模型？</p><p>I&#x2F;O多路复用是指利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I&#x2F;O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。</p><p>其中Redis的网络模型就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器；</p><p>在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>deepseek 本地部署</title>
    <link href="/2025/03/04/deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/"/>
    <url>/2025/03/04/deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>纯新手教学，手把手带你在本地部署一个私有的 deepseek ，再也不用受网络影响。</p></blockquote><span id="more"></span><h1 id="deepseek-本地部署"><a href="#deepseek-本地部署" class="headerlink" title="deepseek 本地部署"></a>deepseek 本地部署</h1><h2 id="Ollama-下载安装"><a href="#Ollama-下载安装" class="headerlink" title="Ollama 下载安装"></a>Ollama 下载安装</h2><ol><li><p>Ollama官网指路：<a href="https://ollama.com/">Ollama</a>，下载这步都会就没必要截图了，如果下载的慢建议科学上网，多试试。</p></li><li><p>在C盘以外的盘新建一个<code>Ollama</code> 文件夹存放ollama的安装位置（为什么要这样做，因为ollama不能指定安装位置）。</p></li><li><p>注意下载完成后不要立刻点击安装，将下载的可行性程序（OllamaSetup.exe）在文件资源管理器中打开，输入cmd</p><p><img src="https://cdn.xzynet.top/deepseek/image-20250303232507110.png" alt="image-20250303232507110"></p></li><li><p>在命令行中执行如下命令：<code>ollamasetup.exe /DIR=+文件夹路径</code>，这个文件夹的路径就是你创建的<code>Ollama</code>文件夹。</p><img src="https://cdn.xzynet.top/deepseek/image-20250303232945622.png" alt="image-20250303232945622" style="zoom:50%;" /></li><li><p>指定位置安装后如下图所示：</p><p><img src="https://cdn.xzynet.top/deepseek/image-20250303233043819.png" alt="image-20250303233043819"></p></li><li><p>现在要修改模型默认下载的位置（因为模型下载也是默认在C盘的，但是一般模型体积会很大，C盘吃不消的），在C盘以外的盘新建一个<code>ollamaimagers</code> 文件夹存放ollama的安装位置。</p></li><li><p>编辑系统环境变量：<code>OLLAMA_MODELS</code>，完成后，保存重启电脑，让环境变量生效。</p><p><img src="https://cdn.xzynet.top/deepseek/image-20250303233607377.png" alt="image-20250303233607377"></p></li></ol><p>小结：现在已经完成了Ollama指定位置的安装，和模型指定位置的安装</p><h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><ol><li><p>模型网址链接：<a href="https://ollama.com/library/deepseek-r1">deepseek-r1</a></p></li><li><p>根据你自己的电脑配置，选择合适的模型进行下载，笔者这里使用的为1.5b模型，在命令行窗口中输入：<code>ollama run deepseek-r1:1.5b</code></p><img src="https://cdn.xzynet.top/deepseek/image-20250303234340579.png" alt="image-20250303234340579" style="zoom:50%;" /></li><li><p>中途如果下载很慢，可以按<code>ctrl + c</code>结束下载，再运行模型下载的命令，会接着继续下载。</p><img src="https://cdn.xzynet.top/deepseek/image-20250303234553432.png" alt="image-20250303234553432" style="zoom:50%;" /></li><li><p>成功下载后，即可与本地deepseek对话。</p></li></ol><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>这是由deepseek推荐的各个模型的显卡配置：</p><table><thead><tr><th align="left">模型规模</th><th align="left">推荐显存（推理）</th><th align="left">推荐显卡（推理）</th><th align="left">推荐显存（训练）</th><th align="left">推荐显卡（训练）</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><strong>1.5B</strong></td><td align="left">≥4GB</td><td align="left">GTX 1660 (6GB)、RTX 3050 (8GB)</td><td align="left">≥8GB</td><td align="left">RTX 3060 (12GB)、RTX 2080 Ti (11GB)</td><td align="left">FP16推理，训练需额外显存。</td></tr><tr><td align="left"><strong>7B</strong></td><td align="left">≥16GB</td><td align="left">RTX 3090 (24GB)、RTX 4090 (24GB)</td><td align="left">≥24GB</td><td align="left">单卡A100 40GB、双RTX 3090（并行）</td><td align="left">无量化时需24GB显存；4位量化可降至约8GB，单卡RTX 3090即可推理。</td></tr><tr><td align="left"><strong>8B</strong></td><td align="left">≥16GB</td><td align="left">RTX 3090 (24GB)、Tesla T4 (16GB)</td><td align="left">≥32GB</td><td align="left">双A100 40GB（并行）</td><td align="left">需注意T4可能因带宽不足导致速度较慢。</td></tr><tr><td align="left"><strong>14B</strong></td><td align="left">≥28GB</td><td align="left">单卡A100 40GB、双RTX 3090（并行）</td><td align="left">≥56GB</td><td align="left">双A100 40GB（并行）或四RTX 3090</td><td align="left">4位量化推理需约14GB，单卡RTX 3090可运行。</td></tr><tr><td align="left"><strong>32B</strong></td><td align="left">≥64GB（FP16）</td><td align="left">双A100 40GB（并行）、四RTX 3090</td><td align="left">≥128GB</td><td align="left">四A100 80GB集群、多卡H100</td><td align="left">需模型并行；4位量化后显存降至约32GB，单A100 40GB可推理。</td></tr><tr><td align="left"><strong>70B</strong></td><td align="left">≥140GB（FP16）</td><td align="left">四A100 40GB（并行）</td><td align="left">≥280GB</td><td align="left">专业集群（如8xA100 80GB）</td><td align="left">4位量化后显存约35GB，单A100 40GB可推理，但需优化库（如vLLM）。</td></tr><tr><td align="left"><strong>671B</strong></td><td align="left">≥1.3TB（FP16）</td><td align="left">大规模分布式系统（如TPU Pod）</td><td align="left">≥2.6TB</td><td align="left">超算集群（数百张A100&#x2F;H100）</td><td align="left">仅限企业和研究机构；需分布式训练框架（如DeepSpeed、Megatron-LM）。</td></tr></tbody></table><h2 id="Ollama-命令"><a href="#Ollama-命令" class="headerlink" title="Ollama 命令"></a>Ollama 命令</h2><ol><li>输入<code>ollama help</code>，即可看到命令帮助，这里最常用的命令就是：<code>ollama list</code> 和<code>ollama run</code></li><li><code>ollama list</code>：查看下载的所有模型</li><li><code>ollama run</code>：运行你下再的模型，命令后面跟模型的名称，如：<code>ollama run deepseek-r1:1.5b</code>，即可重新开始对话。</li><li><code>ollama rm</code>：删除模型，命令后面跟模型的名称，如：<code>ollama rm deepseek-r1:1.5b</code>。</li></ol><p><img src="https://cdn.xzynet.top/deepseek/image-20250303235021310.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deepseek</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2025/02/23/Linux/"/>
    <url>/2025/02/23/Linux/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是Linux的简介</p></blockquote><span id="more"></span><p>图片</p><p>正文</p><p>参考</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端</title>
    <link href="/2025/02/23/%E5%89%8D%E7%AB%AF/"/>
    <url>/2025/02/23/%E5%89%8D%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是前端的简介</p></blockquote><span id="more"></span><p>图片</p><p>正文</p><p>参考</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot3.X 集成 Swagger</title>
    <link href="/2025/02/20/Springboot3-X-%E9%9B%86%E6%88%90-Swagger/"/>
    <url>/2025/02/20/Springboot3-X-%E9%9B%86%E6%88%90-Swagger/</url>
    
    <content type="html"><![CDATA[<blockquote><p>简述Spring Boot 3.X集成Swagger与Knife4j的步骤：引入对应依赖，配置OpenAPI类定义文档信息，通过注解标注Controller接口，并验证访问路径。Knife4j作为Swagger增强工具需JDK≥17，支持OpenAPI3规范。</p></blockquote><span id="more"></span><h2 id="Springboot3-X-集成-Swagger"><a href="#Springboot3-X-集成-Swagger" class="headerlink" title="Springboot3.X 集成 Swagger"></a>Springboot3.X 集成 Swagger</h2><blockquote><p>去<a href="https://blog.csdn.net/XZY__one/article/details/139420345?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22139420345%22,%22source%22:%22XZY__one%22%7D">CSDN</a>查看博主的同款文章。</p></blockquote><p>第一步：创建一个springboot3.X的项目（直接省略，不会的看这里<a href="https://www.cnblogs.com/xiezhr/p/17708711.html">快速搭建SpringBoot3.x项目 - xiezhr - 博客园 (cnblogs.com)</a>）</p><p>第二步：引入Swagger依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Swagger--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第三步：添加配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ant_path_matcher</span><br></code></pre></td></tr></table></figure><blockquote><p>注意事项：我在后面测试的时候好像发现这个配置步骤可有可无。</p></blockquote><p>第四步：新增一个配置类：OpenAPIConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.ExternalDocumentation;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.OpenAPI;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.info.Info;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenAPIConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OpenAPI <span class="hljs-title function_">openAPI</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Swagger 接口文档开始生成&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAPI</span>()<br>                .info(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>()<br>                        .title(<span class="hljs-string">&quot;接口文档标题&quot;</span>)<br>                        .description(<span class="hljs-string">&quot;接口文档的描述信息&quot;</span>)<br>                        .version(<span class="hljs-string">&quot;版本信息：v1.0&quot;</span>))<br>                .externalDocs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExternalDocumentation</span>()<br>                        .description(<span class="hljs-string">&quot;描述&quot;</span>)<br>                        .url(<span class="hljs-string">&quot;/&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第五步：随便写一个Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> io.swagger.v3.oas.annotations.Operation;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.annotations.Parameter;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.annotations.tags.Tag;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Tag(name = &quot;测试Controller&quot;, description = &quot;这是描述&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-meta">@Operation(summary = &quot;测试接口&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-meta">@Parameter(name = &quot;name&quot;, description = &quot;名称&quot;)</span> String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第六步：启动项目，点击链接<a href="http://localhost:8080/swagger-ui/index.html#/">Swagger UI</a>查看Swagger描述</p><blockquote><p>注意：一般都是<code>http://localhost:8080/swagger-ui/index.html#/</code>这个链接，如果打不开，大概率是你的端口问题，替换<code>8080</code>修改成你自己的端口号，或者项目路径有统一的前缀等等…</p></blockquote><p><img src="https://cdn.xzynet.top/technicalArticle/Swagger/image-20240603165317641.png" alt="Swagger界面"></p><p>看到这个界面，就代表成功了。</p><h2 id="Springboot3-X-集成-knife4j"><a href="#Springboot3-X-集成-knife4j" class="headerlink" title="Springboot3.X 集成 knife4j"></a>Springboot3.X 集成 knife4j</h2><p>前提要求：具体看官方文档<a href="https://doc.xiaominfo.com/docs/quick-start">快速开始 | Knife4j (xiaominfo.com)</a></p><ul><li>Spring Boot 3 只支持OpenAPI3规范</li><li>Knife4j提供的starter已经引用springdoc-openapi的jar，开发者需注意避免jar包冲突</li><li>JDK版本必须 &gt;&#x3D; 17</li></ul><p>第一步：引入knife4j依赖，如果之前引入了Swagger依赖，最好注释掉，maven 最好 clear 一下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--knif4j--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-openapi3-jakarta-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二步：新增一个配置类：OpenAPIConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.ExternalDocumentation;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.OpenAPI;<br><span class="hljs-keyword">import</span> io.swagger.v3.oas.models.info.Info;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenAPIConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OpenAPI <span class="hljs-title function_">openAPI</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Swagger 接口文档开始生成&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAPI</span>()<br>                .info(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>()<br>                        .title(<span class="hljs-string">&quot;接口文档标题&quot;</span>)<br>                        .description(<span class="hljs-string">&quot;接口文档的描述信息&quot;</span>)<br>                        .version(<span class="hljs-string">&quot;版本信息：v1.0&quot;</span>))<br>                .externalDocs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExternalDocumentation</span>()<br>                        .description(<span class="hljs-string">&quot;描述&quot;</span>)<br>                        .url(<span class="hljs-string">&quot;/&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步：启动项目，点击链接<a href="http://127.0.0.1:8080/doc.html#/home">knife4j页面</a></p><p><img src="https://cdn.xzynet.top/technicalArticle/Swagger/image-20240603171805457.png" alt="knife4j界面"></p><p>看到这个界面，就代表成功了。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring boot</tag>
      
      <tag>Swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2025/02/20/%E7%AE%97%E6%B3%95/"/>
    <url>/2025/02/20/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理了常见算法题型与LeetCode题解，涵盖数组、字符串、哈希表、双指针、链表等数据结构，以及栈、队列、回溯、动态规划等核心算法。适合算法初学者及面试备考者，帮助掌握高频题目解题技巧，提升编码效率。</p></blockquote><span id="more"></span><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>数组是存放在连续内存空间上的相同类型数据的集合。</p><p>注意：</p><ul><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的</li></ul><p>正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。<strong>数组的元素是不能删的，只能覆盖。</strong></p></blockquote><p>第一题：<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//自己写的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == target)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//做法二：二分查找。这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span><br>        <span class="hljs-keyword">if</span> (target &lt; nums[<span class="hljs-number">0</span>] || target &gt; nums[nums.length - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    <br>    <span class="hljs-comment">//left right mid都是指数组的索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">//目标元素在数组的右边</span><br>            <span class="hljs-keyword">if</span> (target &gt; nums[mid]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>                mid = (left + right) / <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-comment">//目标元素在数组的左边</span><br>            <span class="hljs-keyword">if</span> (target &lt; nums[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                mid = (left + right) / <span class="hljs-number">2</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (target == nums[mid]) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第二题：<a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//暴力</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> nums.length;<br>       <span class="hljs-comment">//外循环：遍历数组的</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>           <span class="hljs-keyword">if</span> (nums[i] == val) &#123;<br><br>               <span class="hljs-comment">//内循环：更新数组</span><br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; size; j++) &#123;<br>                   <span class="hljs-comment">//将i后面的元素都往前移动一位，数组的长度--</span><br>                   nums[j - <span class="hljs-number">1</span>] = nums[j];<br><br>               &#125;<br>               i--; <span class="hljs-comment">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span><br>               size--;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> size;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 双指针：操作的是同一个数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">slowIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//慢指针：获取新数组的元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//快指针：获取新数组中需要更新的位置</span><br><br>        <span class="hljs-keyword">for</span> (fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;<br>            <span class="hljs-comment">//新数组中不应该有目标元素</span><br>            <span class="hljs-keyword">if</span> (nums[fastIndex] != val) &#123;<br>                nums[slowIndex] = nums[fastIndex];<br>                slowIndex++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第三题：<a href="https://leetcode.cn/problems/move-zeroes/description/">283. 移动零 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//两两交换：将 非0元素 与 第一个为0元素的索引 进行交换</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//i 用于遍历数组中的每个元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//j 用于跟踪最后一个非零元素的位置</span><br>        <span class="hljs-keyword">while</span> (i &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[j];<br>                nums[j] = nums[i];<br>                nums[i] = tmp;<br>                j++;<br>            &#125;<br>            i++;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第四题：<a href="https://leetcode.cn/problems/backspace-string-compare/description/">844. 比较含退格的字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backspaceCompare</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ssb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tsb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-comment">// 分别处理两个字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                ssb.append(c); <span class="hljs-comment">// 模拟进栈的操作</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ssb.length() &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 栈非空才能弹出</span><br>                ssb.deleteCharAt(ssb.length() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 将栈顶元素弹出</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                tsb.append(c); <span class="hljs-comment">// 模拟进栈的操作</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tsb.length() &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 栈非空才能弹出</span><br>                tsb.deleteCharAt(tsb.length() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 将栈顶元素弹出</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ssb.toString().equals(tsb.toString());<br>    &#125;<br></code></pre></td></tr></table></figure><p>第五题：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//自己写的</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            arr[i] = nums[i] * nums[i];<br>        &#125;<br>        <br>        <span class="hljs-comment">//对arr进行递增排序</span><br>        Arrays.sort(arr);<br>        <br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//双指针思路：</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> result.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;<br>                <span class="hljs-comment">// 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置</span><br>                result[index--] = nums[left] * nums[left];<br>                ++left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[index--] = nums[right] * nums[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第六题：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//暴力解法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                sum = sum + nums[j];<br>                <span class="hljs-keyword">if</span> (sum &gt;= target)&#123;<br>                    ans = Math.min(ans,j - i + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*滑动窗口（相当于双指针）</span><br><span class="hljs-comment">     窗口内是什么？</span><br><span class="hljs-comment">     如何移动窗口的起始位置？</span><br><span class="hljs-comment">     如何移动窗口的结束位置？</span><br><span class="hljs-comment">     */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen2</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">subLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>     <span class="hljs-comment">//循环表示：滑动窗口的终止位置</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++) &#123;<br>         sum += nums[right];<br><br>         <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;  <span class="hljs-comment">//窗口就要向前移动了（也就是该缩小了）</span><br>             subLength = right - left + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 取子序列的长度</span><br>             result = Math.min(result, subLength);<br>             sum -= nums[left++];<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> result == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : result;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h3><ul><li><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮(opens new window)</a></li><li><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>第一题：<a href="https://leetcode.cn/problems/reverse-string/description/">344. 反转字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//双指针交换首尾元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[i];<br>            s[i] = s[j];<br>            s[j] = temp;<br>            j--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第二题：<a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span>[] chs = s.toCharArray();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i += <span class="hljs-number">2</span> * k) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-comment">//判断尾数够不够k个，取决于end指针的位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Math.min(chs.length - <span class="hljs-number">1</span>,start + k - <span class="hljs-number">1</span>);<br>            <br>            <span class="hljs-keyword">while</span> (start &lt;end)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> chs[start];<br>                chs[start] = chs[end];<br>                chs[end] = temp;<br>                start++;<br>                end--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(chs);<br>    &#125;<br></code></pre></td></tr></table></figure><p>第三题：<a href="https://kamacoder.com/problempage.php?pid=1064">54. 替换数字（第八期模拟笔试） (kamacoder.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.next();<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(str);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sb.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (sb.charAt(i) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; sb.charAt(i) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                sb.deleteCharAt(i);<br>                sb.insert(i,<span class="hljs-string">&quot;number&quot;</span>);<br>                i = i + <span class="hljs-number">5</span>;<br>            &#125;<br>        &#125;<br><br>        System.out.println(String.valueOf(sb).toString());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第四题：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词 - 力扣（LeetCode）</a>（困难）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 1.去除首尾以及中间多余空格</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> removeSpace(s);<br>        <span class="hljs-comment">//System.out.println(sb);</span><br><br>        <span class="hljs-comment">// 2.反转单词.以空格为界限，进行反转</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br><br>        String[] split = str.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-comment">//双指针进行反转单词</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> split.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; split.length / <span class="hljs-number">2</span>; i++, j--) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> split[i];<br>            split[i] = split[j];<br>            split[j] = temp;<br>        &#125;<br><br>        <span class="hljs-comment">//System.out.println(Arrays.toString(split));</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; split.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == split.length - <span class="hljs-number">1</span>)&#123;<br>                s1.append(split[i]);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                s1.append(split[i]).append(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//将StringBuilder转为string</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> s1.toString();<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//双指针移除空格</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title function_">removeSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//先移除首尾空格</span><br>        <span class="hljs-keyword">while</span> (s.charAt(start) == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (s.charAt(end) == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            end--;<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-keyword">while</span> (start &lt;= end)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(start);<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>)&#123; <span class="hljs-comment">//本身不能为&#x27; &#x27; 或者sb的最后一位不能是&#x27; &#x27;</span><br>                sb.append(c);<br>            &#125;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第五题：<a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459. 重复的子字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">//将字符串翻倍</span><br>        sb.append(s).append(s);<br><br>        <span class="hljs-comment">//掐头去尾</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> sb.substring(<span class="hljs-number">1</span>, sb.length() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//判断原来的字符串是否包含在substring中</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">contains</span> <span class="hljs-operator">=</span> substring.contains(s);<br><br>        <span class="hljs-keyword">return</span> contains;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><blockquote><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。牺牲了空间换取了时间</p><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul></blockquote><p>第一题：<a href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//暴力</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram2</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">char</span>[] ch_s = s.toCharArray();<br>        <span class="hljs-type">char</span>[] ch_t = t.toCharArray();<br><br>        Arrays.sort(ch_s);<br>        Arrays.sort(ch_t);<br><br>        <span class="hljs-comment">//统计s中有哪些字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch_s.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ch_s[i] != ch_t[i])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历s，将s中含有的字符存储在一个数组中</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-type">char</span>[] ch_s = s.toCharArray();<br>        <span class="hljs-type">char</span>[] ch_t = t.toCharArray();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch_s.length; i++) &#123;<br>            <span class="hljs-comment">//将s字符存入数组中</span><br>            arr[ch_s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch_t.length; i++) &#123;<br>            <span class="hljs-comment">//将t字符从数组中删去</span><br>            arr[ch_t[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br><br>        <span class="hljs-comment">//只要数组中有一个不为0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第二题：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-comment">//特殊情况</span><br>        <span class="hljs-keyword">if</span> (nums1 == <span class="hljs-literal">null</span> || nums1.length == <span class="hljs-number">0</span> || nums2 == <span class="hljs-literal">null</span> || nums2.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        Set&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; resSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//遍历数组1：这也是一个去重的过程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums1) &#123;<br>            set1.add(i);<br>        &#125;<br><br>        <span class="hljs-comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums2) &#123;<br>            <span class="hljs-keyword">if</span> (set1.contains(i)) &#123;<br>                resSet.add(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//将Set转为数组</span><br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[resSet.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历resSet，将resSet中的每一个元素存入array数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : resSet) &#123;<br>            array[j++] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第三题：<a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 记录已经计算过的数字，避免重复和无限循环</span><br>        Set&lt;Integer&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span> &amp;&amp; !record.contains(n)) &#123;<br>            record.add(n);<br>            n = getNextNumber(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNextNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">10</span>;<br>            res += temp * temp;<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第四题：<a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//暴力解法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    <br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//慢指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//快指针</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                sum = nums[i] + nums[j];<br>                <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                    res[<span class="hljs-number">0</span>] = i;<br>                    res[<span class="hljs-number">1</span>] = j;<br>                    <span class="hljs-keyword">return</span> res;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Map解法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-comment">//map:存储遍历过的元素 将元素作为key，数组下标作为value</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> target - nums[i];    <span class="hljs-comment">//遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(temp)) &#123;<br>                res[<span class="hljs-number">1</span>] = i;<br>                res[<span class="hljs-number">0</span>] = map.get(temp);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            map.put(nums[i], i);    <span class="hljs-comment">//如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>第五题：<a href="https://leetcode.cn/problems/4sum-ii/description/">454. 四数相加 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//暴力解法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums2.length; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; nums3.length; k++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; g &lt; nums4.length; g++) &#123;<br>                        <span class="hljs-keyword">if</span> (nums1[i] + nums2[j] + nums3[k] + nums4[g] == <span class="hljs-number">0</span>) &#123;<br>                            count++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//哈希表：map解法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br><br>        <span class="hljs-comment">//统计两个数组中的元素之和，同时统计出现的次数，放入map</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums1) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : nums2) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> i + j;<br>                map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums3) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : nums4) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> i + j;<br>                res += map.getOrDefault(-sum, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第六题：<a href="https://leetcode.cn/problems/ransom-note/description/">383. 赎金信 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//暴力：遍历这两个字符串，</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-type">char</span>[] ch_r = ransomNote.toCharArray();<br>        <span class="hljs-type">char</span>[] ch_m = magazine.toCharArray();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch_r.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; ch_m.length; j++) &#123;<br>                <span class="hljs-comment">//遍历：如果r中的字符串在m存在，则将r中这个字符赋值为&#x27;0&#x27;</span><br>                <span class="hljs-keyword">if</span> (ch_r[i] == ch_m[j])&#123;<br>                    ch_r[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    ch_m[j] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历看这个ch_r是否都为&#x27;0&#x27;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch_r.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ch_r[i] != <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//哈希解法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ransomNote.length() &gt; magazine.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 定义一个哈希映射数组</span><br>        <span class="hljs-type">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-type">char</span>[] ch_r = ransomNote.toCharArray();<br>        <span class="hljs-type">char</span>[] ch_m = magazine.toCharArray();<br><br><br>        <span class="hljs-comment">//遍历magazine记录magazine里各个字符出现的次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch_m.length; i++) &#123;<br>            record[ch_m[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历ransomNote,在record数组中对应的字符个数做--操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ch_r.length; i++) &#123;<br>            record[ch_r[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <br>        <span class="hljs-comment">//如果小于0，则证明magazine中不完全包含ransomNote</span><br>        <span class="hljs-comment">//如果大于0，则证明magazine中完全包含ransomNote，且还有多余的字母</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; record.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第七题：<a href="https://leetcode.cn/problems/3sum/description/">15. 三数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//暴力</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        HashSet&lt;List&lt;Integer&gt;&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; nums.length; k++) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">//排序后存放在set中的集合能保证没有重复</span><br>                        List&lt;Integer&gt; list = Arrays.asList(nums[i], nums[j], nums[k]);<br>                        Collections.sort(list);<br>                        set.add(list);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(set);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//双指针思想</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-comment">//先对数组进行排序</span><br>       Arrays.sort(nums);<br><br>       <span class="hljs-comment">// 找出a + b + c = 0</span><br>       <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>           <span class="hljs-comment">//排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>           <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>               <span class="hljs-keyword">return</span> result;<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">//去重a</span><br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<br><br>           <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>           <span class="hljs-comment">//不能相等，如果相等这就只剩下两个数字了，不满足三元组</span><br>           <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br><br>               <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//和有点大，故将right往左移动</span><br>                   right--;<br>               &#125;<br><br>               <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//和有点小，故将left往右移动</span><br>                   left++;<br>               &#125;<br><br>               <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//满足要求</span><br>                   result.add(Arrays.asList(nums[i], nums[left], nums[right]));<br><br>                   <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对 b 和 c 去重</span><br>                   <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                   <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                   right--;<br>                   left++;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> result;<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>第八题：<a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//双指针思路</span><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// nums[i] &gt; target 直接返回, 剪枝操作</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt; target) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i]) &#123; <span class="hljs-comment">// 对nums[i]去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j]) &#123; <span class="hljs-comment">// 对nums[j]去重</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target int会溢出</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];<br><br>                    <span class="hljs-keyword">if</span> (sum &gt; target) &#123; <span class="hljs-comment">// 和有点大，故将right往左移动</span><br>                        right--;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (sum &lt; target) &#123; <span class="hljs-comment">// 和有点小，故将left往右移动</span><br>                        left++;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (sum == target) &#123; <span class="hljs-comment">// 满足要求</span><br>                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                            right--;<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                            left++;<br><br>                        left++;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>第一题：<a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">//双指针思想</span><br>        <span class="hljs-comment">//定义一个快指针：用来查找不是目标元素的索引</span><br>        <span class="hljs-comment">//定义一个慢指针：用来将不是目标元素的数据放入一个数组中，知道快指针遍历完目标数组</span><br>        <br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;      <span class="hljs-comment">//定义快指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//定义慢指针</span><br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != val) &#123;<br>                nums[slow] = nums[i];<br>                slow++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//System.out.println(Arrays.toString(arr));</span><br>        <span class="hljs-comment">//System.out.println(Arrays.toString(nums));</span><br><br>        <span class="hljs-comment">//此时这个j就相当于这个新数组的大小，也就是删除目标元素后数组的大小</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第二题：<a href="https://leetcode.cn/problems/reverse-string/description/">344. 反转字符串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[i];<br>            s[i] = s[j];<br>            s[j] = temp;<br>            j--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第三题：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 1.去除首尾以及中间多余空格</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> removeSpace(s);<br>        <span class="hljs-comment">//System.out.println(sb);</span><br><br>        <span class="hljs-comment">// 2.反转单词.以空格为界限，进行反转</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br><br>        String[] split = str.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-comment">//双指针进行反转单词</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> split.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; split.length / <span class="hljs-number">2</span>; i++, j--) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> split[i];<br>            split[i] = split[j];<br>            split[j] = temp;<br>        &#125;<br><br>        <span class="hljs-comment">//System.out.println(Arrays.toString(split));</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; split.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == split.length - <span class="hljs-number">1</span>)&#123;<br>                s1.append(split[i]);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                s1.append(split[i]).append(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//将StringBuilder转为string</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> s1.toString();<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title function_">removeSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (s.charAt(start) == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (s.charAt(end) == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            end--;<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-keyword">while</span> (start &lt;= end)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(start);<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                sb.append(c);<br>            &#125;<br>            start++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第四题：<a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            temp = cur.next;<span class="hljs-comment">// 保存下一个节点</span><br>            cur.next = prev;<br>            prev = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第五题：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyNode.next = head;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-operator">=</span> dummyNode;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slowIndex</span> <span class="hljs-operator">=</span> dummyNode;<br><br>        <span class="hljs-comment">// 只要快慢指针相差 n 个结点即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>            fastIndex = fastIndex.next;<br>        &#125;<br><br>        <span class="hljs-comment">//同时移动，直到fast指向末尾</span><br>        <span class="hljs-keyword">while</span> (fastIndex != <span class="hljs-literal">null</span>)&#123;<br>            fastIndex = fastIndex.next;<br>            slowIndex = slowIndex.next;<br>        &#125;<br><br>        <span class="hljs-comment">//此时 slowIndex 的位置就是待删除元素的前一个位置。</span><br>        slowIndex.next = slowIndex.next.next;<br>        <span class="hljs-keyword">return</span> dummyNode.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第六题：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curA</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curB</span> <span class="hljs-operator">=</span> headB;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 求链表A的长度</span><br>            lenA++;<br>            curA = curA.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (curB != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 求链表B的长度</span><br>            lenB++;<br>            curB = curB.next;<br>        &#125;<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-comment">// 让curA为最长链表的头，lenA为其长度</span><br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA) &#123;<br>            <span class="hljs-comment">// 1. swap (lenA, lenB);</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmpLen</span> <span class="hljs-operator">=</span> lenA;<br>            lenA = lenB;<br>            lenB = tmpLen;<br>            <span class="hljs-comment">// 2. swap (curA, curB);</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmpNode</span> <span class="hljs-operator">=</span> curA;<br>            curA = curB;<br>            curB = tmpNode;<br>        &#125;<br>        <span class="hljs-comment">// 求长度差</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> lenA - lenB;<br>        <span class="hljs-comment">// 让curA和curB在同一起点上（末尾位置对齐）</span><br>        <span class="hljs-keyword">while</span> (gap-- &gt; <span class="hljs-number">0</span>) &#123;<br>            curA = curA.next;<br>        &#125;<br>        <span class="hljs-comment">// 遍历curA 和 curB，遇到相同则直接返回</span><br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curA == curB) &#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>            curA = curA.next;<br>            curB = curB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>第七题：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<span class="hljs-comment">// 有环</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> fast;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span><br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1.next;<br>                    index2 = index2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第八题：<a href="https://leetcode.cn/problems/3sum/description/">15. 三数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 先对数组进行排序</span><br>        Arrays.sort(nums);<br><br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重a</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 不能相等，如果相等这就只剩下两个数字了，不满足三元组</span><br>            <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br><br>                <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 和有点大，故将right往左移动</span><br>                    right--;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 和有点小，故将left往右移动</span><br>                    left++;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 满足要求</span><br>                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));<br><br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对 b 和 c 去重</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                        right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                        left++;<br><br>                    right--;<br>                    left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第九题：<a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// nums[i] &gt; target 直接返回, 剪枝操作</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt; target) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i]) &#123; <span class="hljs-comment">// 对nums[i]去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j]) &#123; <span class="hljs-comment">// 对nums[j]去重</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target int会溢出</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];<br><br>                    <span class="hljs-keyword">if</span> (sum &gt; target) &#123; <span class="hljs-comment">// 和有点大，故将right往左移动</span><br>                        right--;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (sum &lt; target) &#123; <span class="hljs-comment">// 和有点小，故将left往右移动</span><br>                        left++;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (sum == target) &#123; <span class="hljs-comment">// 满足要求</span><br>                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                            right--;<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                            left++;<br><br>                        left++;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>链表分为单链表和双链表：</p><ul><li>单链表：每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针）。单链表中的指针域只能指向节点的下一个节点。</li><li>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</li><li>循环链表：顾名思义，就是链表首尾相连。</li></ul><p>链表与数组的比较：</p><ul><li>定义数组时长度是固定的，链表的长度不固定。</li><li>数组适合频繁的查询，链表适合频繁增删。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//链表的定义</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-comment">// 结点的值</span><br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-comment">// 下一个结点</span><br>    ListNode next;<br><br>    <span class="hljs-comment">// 节点的构造函数(无参)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有一个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br><br>    <span class="hljs-comment">// 节点的构造函数(有两个参数)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, ListNode next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一题：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//设置虚拟头节点</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">//一个空链表不需要任何操作</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">//因为删除可能涉及头节点，所以设置dummy节点，统一操作</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);    <span class="hljs-comment">//是处理可能需要删除头节点的情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;   <span class="hljs-comment">//记录当前节点的前一个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;    <span class="hljs-comment">//遍历链表</span><br><br><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;   <span class="hljs-comment">//空链表不需要任何操作</span><br>            <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>                pre.next = cur.next;    <span class="hljs-comment">//pre的下一个节点指向cur的下一个节点</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = cur;  <span class="hljs-comment">//将pre更新为cur</span><br>            &#125;<br>            cur = cur.next; <span class="hljs-comment">//将cur更新为下一个节点</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;  <span class="hljs-comment">//返回dummy的下一个节点，这才是实际的头节点</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>第二题：<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><br>    <span class="hljs-comment">//手写一个单链表</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//size存储链表元素的个数</span><br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">//虚拟头结点</span><br>    ListNode head;<br><br>    <span class="hljs-comment">//初始化链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLinkedList</span><span class="hljs-params">()</span> &#123;<br>        size = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-comment">//如果index非法，直接返回-1</span><br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">//包含一个虚拟节点，所以查找第index + 1 个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index; i++) &#123;<br>            currentNode = currentNode.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> currentNode.val;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">//在链表最前面插入一个节点，等价于在第0个元素前添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(<span class="hljs-number">0</span>, val);<br>    &#125;<br><br>    <span class="hljs-comment">//在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(size, val);<br>    &#125;<br><br>    <span class="hljs-comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span><br>    <span class="hljs-comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span><br>    <span class="hljs-comment">// 如果 index 大于链表的长度，则返回空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>            index = <span class="hljs-number">0</span>;<br>        &#125;<br>        size++;<br><br>        <span class="hljs-comment">//找到要插入节点的前驱</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pred = pred.next;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">toAdd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        toAdd.next = pred.next;<br>        pred.next = toAdd;<br>    &#125;<br><br><br>    <span class="hljs-comment">//删除第index个节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        size--;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>            head = head.next;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pred = pred.next;<br>        &#125;<br>        pred.next = pred.next.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三题：<a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//记录当前节点的前一个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<span class="hljs-comment">//遍历链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//用于交换链表</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            temp = cur.next;<span class="hljs-comment">// 保存下一个节点</span><br>            cur.next = prev;<br>            prev = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第四题：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dumyhead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 设置一个虚拟头结点</span><br>        dumyhead.next = head; <span class="hljs-comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dumyhead;<br>        ListNode temp; <span class="hljs-comment">// 临时节点，保存两个节点后面的节点</span><br>        ListNode firstnode; <span class="hljs-comment">// 临时节点，保存两个节点之中的第一个节点</span><br>        ListNode secondnode; <span class="hljs-comment">// 临时节点，保存两个节点之中的第二个节点</span><br><br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>            temp = cur.next.next.next;<br>            firstnode = cur.next;<br>            secondnode = cur.next.next;<br>            cur.next = secondnode;       <span class="hljs-comment">// 步骤一</span><br>            secondnode.next = firstnode; <span class="hljs-comment">// 步骤二</span><br>            firstnode.next = temp;      <span class="hljs-comment">// 步骤三</span><br>            cur = firstnode; <span class="hljs-comment">// cur移动，准备下一轮交换</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dumyhead.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第五题：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyNode.next = head;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-operator">=</span> dummyNode;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slowIndex</span> <span class="hljs-operator">=</span> dummyNode;<br><br>        <span class="hljs-comment">// 只要快慢指针相差 n 个结点即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            fastIndex = fastIndex.next;<br>        &#125;<br><br>        <span class="hljs-comment">//同时移动，直到fast指向末尾</span><br>        <span class="hljs-keyword">while</span> (fastIndex != <span class="hljs-literal">null</span>) &#123;<br>            fastIndex = fastIndex.next;<br>            slowIndex = slowIndex.next;<br>        &#125;<br><br>        <span class="hljs-comment">//此时 slowIndex 的位置就是待删除元素的前一个位置。</span><br>        slowIndex.next = slowIndex.next.next;<br>        <span class="hljs-keyword">return</span> dummyNode.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第六题：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a>（困难）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curA</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curB</span> <span class="hljs-operator">=</span> headB;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 求链表A的长度</span><br>            lenA++;<br>            curA = curA.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (curB != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 求链表B的长度</span><br>            lenB++;<br>            curB = curB.next;<br>        &#125;<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-comment">// 让curA为最长链表的头，lenA为其长度</span><br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA) &#123;<br>            <span class="hljs-comment">// 1. swap (lenA, lenB);</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmpLen</span> <span class="hljs-operator">=</span> lenA;<br>            lenA = lenB;<br>            lenB = tmpLen;<br>            <span class="hljs-comment">// 2. swap (curA, curB);</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmpNode</span> <span class="hljs-operator">=</span> curA;<br>            curA = curB;<br>            curB = tmpNode;<br>        &#125;<br>        <span class="hljs-comment">// 求长度差</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> lenA - lenB;<br>        <span class="hljs-comment">// 让curA和curB在同一起点上（末尾位置对齐）</span><br>        <span class="hljs-keyword">while</span> (gap-- &gt; <span class="hljs-number">0</span>) &#123;<br>            curA = curA.next;<br>        &#125;<br>        <span class="hljs-comment">// 遍历curA 和 curB，遇到相同则直接返回</span><br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curA == curB) &#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>            curA = curA.next;<br>            curB = curB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>第七题：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a>（困难）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;       <span class="hljs-comment">//慢指针：一次走一个节点</span><br>            fast = fast.next.next;  <span class="hljs-comment">//快指针：一次走两个节点</span><br><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<span class="hljs-comment">// 有环</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> fast; <span class="hljs-comment">//快慢指针相遇的点</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">//头节点</span><br>                <br>                <span class="hljs-comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span><br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1.next;<br>                    index2 = index2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote><p>队列是先进先出，栈是先进后出。</p></blockquote><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png"></p><p><code>Stack</code>方法摘要：</p><ul><li><code>push()</code>：把项压入堆栈顶部</li><li><code>pop()</code>：移除堆栈顶部的对象，并作为此函数的值返回该对象</li><li><code>empty()</code>：测试堆栈是否为空。 </li><li><code>peek()</code>：查看堆栈顶部的对象，但不从堆栈中移除它。</li><li><code>search()</code>：返回对象在堆栈中的位置，以 1 为基数。返回值 -1 表示此对象不在堆栈中</li></ul><p><code>Queue</code>方法摘要：</p><ul><li><code>add()</code>：将指定的元素插入此队列。成功时返回 true，如果当前没有可用的空间，则抛出异常。 </li><li><code>offer()</code>：将指定的元素插入此队列。如果该元素已添加到此队列，则返回 true；否则返回 false </li><li><code>remove()</code>：获取并移除此队列的头。此方法与 poll 唯一的不同在于：此队列为空时将抛出一个异常。</li><li><code>poll()</code>：获取并移除此队列的头，如果此队列为空，则返回 null。</li><li><code>peek()</code>：获取但不移除此队列的头；如果此队列为空，则返回 null。 </li><li><code>element()</code>：获取，但是不移除此队列的头。此方法与 peek 唯一的不同在于：此队列为空时将抛出一个异常。</li></ul><p>第一题：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232. 用栈实现队列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <span class="hljs-comment">/*用栈实现队列 leetcode_232 */</span><br><br>    Stack&lt;Integer&gt; stackIn;<br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在这里初始化您的数据结构。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        stackIn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 负责进栈</span><br>        stackOut = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 负责出栈</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将元素 x 推到队列的后面。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stackIn.push(x);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从队列前面移除元素并返回该元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        dumpstackIn();<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到前面的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        dumpstackIn();<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回队列是否为空：只要进栈和出战同时为空，则队列为空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dumpstackIn</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!stackOut.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span> (!stackIn.isEmpty()) &#123;<br>            stackOut.push(stackIn.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第二题：<a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; queue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.add(x);<br>    &#125;<br><br>    <span class="hljs-comment">//移除并返回栈顶元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        rePosition();<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br><br>    <span class="hljs-comment">//返回栈顶的元素，注意并不移除</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        rePosition();   <span class="hljs-comment">//实际上就是返回队列最后一个元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> queue.poll();<br>        queue.add(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br><br>    <span class="hljs-comment">//将队列中最后一个元素弹出，就要先将队列中最后一个元素的前面所有元素弹出再重新添加到队列中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rePosition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();    <span class="hljs-comment">//获取队列的大小</span><br>        size--;<br>        <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>)<br>            queue.add(queue.poll());    <span class="hljs-comment">//将队列中最后一个元素前面的所有元素弹出再重新添加到队列中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三题：<a href="https://leetcode.cn/problems/valid-parentheses/description/">20. 有效的括号 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//剪枝操作</span><br>        <span class="hljs-keyword">if</span> (s.length() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//这个字符串的长度不为偶数，直接返回false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//创建一个双端队列</span><br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span> ch;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            ch = s.charAt(i);<br>            <span class="hljs-comment">//碰到左括号，就把相应的右括号入栈</span><br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deque.isEmpty() || deque.peek() != ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//右括号判断和栈顶元素匹配</span><br>                deque.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后判断栈中元素是否匹配</span><br>        <span class="hljs-keyword">return</span> deque.isEmpty();<br>    &#125;<br></code></pre></td></tr></table></figure><p>第四题：<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//用栈操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">removeDuplicates1</span><span class="hljs-params">(String S)</span> &#123;<br>        <span class="hljs-comment">//ArrayDeque会比LinkedList在除了删除元素这一点外会快一点</span><br>        ArrayDeque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">char</span> ch;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; S.length(); i++) &#123;<br>            ch = S.charAt(i);<br>            <span class="hljs-keyword">if</span> (deque.isEmpty() || deque.peek() != ch) &#123;<br>                deque.push(ch);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                deque.pop();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//剩余的元素即为不重复的元素</span><br>        <span class="hljs-keyword">while</span> (!deque.isEmpty()) &#123;<br>            str = deque.pop() + str;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br><br>    <span class="hljs-comment">//用字符串代替栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">removeDuplicates2</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 将 res 当做栈</span><br>        <span class="hljs-comment">// 也可以用 StringBuilder 来修改字符串，速度更快</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><br>        <span class="hljs-comment">// top为 res 的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br><br>            <span class="hljs-keyword">if</span> (top &gt;= <span class="hljs-number">0</span> &amp;&amp; res.charAt(top) == c) &#123; <span class="hljs-comment">//当 top &gt; 0, 即栈中有字符时，当前字符如果和栈中字符相等，</span><br>                res.deleteCharAt(top);  <span class="hljs-comment">//弹出栈顶字符，同时 top--</span><br>                top--;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//否则，将该字符入栈，同时top++</span><br>                res.append(c);<br>                top++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br><br>    <span class="hljs-comment">//双指针</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">removeDuplicates3</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] ch = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (fast &lt; s.length()) &#123;<br>            <span class="hljs-comment">// 直接用fast指针覆盖slow指针的值</span><br>            ch[slow] = ch[fast];<br>            <span class="hljs-comment">// 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了</span><br>            <span class="hljs-keyword">if</span> (slow &gt; <span class="hljs-number">0</span> &amp;&amp; ch[slow] == ch[slow - <span class="hljs-number">1</span>]) &#123;<br>                slow--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch, <span class="hljs-number">0</span>, slow);<br>    &#125;<br></code></pre></td></tr></table></figure><p>第五题：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//用栈来处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br><br>        <span class="hljs-keyword">for</span> (String s : tokens) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;+&quot;</span>.equals(s)) &#123;        <span class="hljs-comment">// leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span><br>                stack.push(stack.pop() + stack.pop());      <span class="hljs-comment">// 注意 - 和 / 需要特殊处理</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-&quot;</span>.equals(s)) &#123;<br>                stack.push(-stack.pop() + stack.pop());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;*&quot;</span>.equals(s)) &#123;<br>                stack.push(stack.pop() * stack.pop());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/&quot;</span>.equals(s)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp2</span> <span class="hljs-operator">=</span> stack.pop();<br>                stack.push(temp2 / temp1);<br>            &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//将数字存入栈中，不要忘记转为int再存入</span><br>                stack.push(Integer.valueOf(s));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br></code></pre></td></tr></table></figure><p>第六题：<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//暴力：不能完全通过测试用例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//剪枝操作</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; k + i; j++) &#123;<br>                <span class="hljs-comment">// 遍历小区间中的最大值</span><br>                <span class="hljs-keyword">while</span> (j &lt; k + i &amp;&amp; j &lt; nums.length) &#123;<br><br>                    <span class="hljs-keyword">if</span> (nums[j] &gt; max) &#123;<br>                        max = nums[j];<br>                        j++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        j++;<br>                    &#125;<br>                &#125;<br>                res[index] = max;<br>                max = Integer.MIN_VALUE;<br>                index++;<br>                <span class="hljs-keyword">if</span> (index == nums.length - k + <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第七题：<a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//通过map，list来实现的</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">// key存放元素，value存放元素出现的次数</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-comment">// 当集合中有这个元素时，就使这个元素的value+1，当集合中没有这个元素时，就添加0 + 1</span><br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历map，将value从大到小排序，放入数组中</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        Set&lt;Integer&gt; keySet = map.keySet();<br>        <span class="hljs-keyword">for</span> (Integer key : keySet) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>            list.add(value);<br>        &#125;<br><br>        <span class="hljs-comment">// 排序(从大到小)</span><br>        list.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o2 - o1;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// System.out.println(list);//[3, 2, 1]</span><br><br>        <span class="hljs-comment">// 通过value获取对应的key，只取前k个value对应的key</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k;) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> list.get(i);<br>            <span class="hljs-comment">// 遍历map</span><br>            <span class="hljs-keyword">for</span> (Integer key : keySet) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> map.get(key);<br>                <span class="hljs-keyword">if</span> (Objects.equals(value, val)) &#123;<br>                    res[i] = key;<br>                    i++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote><p>二叉树的分类</p><ul><li>满二叉树：如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树。</li><li>完全二叉树</li><li>二叉搜索树</li><li>平衡二叉搜索树</li></ul></blockquote><h2 id="回溯（递归）算法"><a href="#回溯（递归）算法" class="headerlink" title="回溯（递归）算法"></a>回溯（递归）算法</h2><blockquote><p>提示：拿到一道题，先想暴力解法，发现有点不能确定几层循环后，想起回溯，回溯题目都可以抽象成一个树形结构</p><p>回溯算法的三部曲：</p><ol><li>回溯函数模板返回值以及参数</li><li>回溯函数终止条件</li><li>回溯搜索的遍历过程</li></ol></blockquote><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯算法的模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合第一题：<a href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//回溯（未剪枝）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backtracking(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-comment">//确定终止条件</span><br>        <span class="hljs-keyword">if</span> (path.size() == k) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//单层搜索的逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= n; i++) &#123; <span class="hljs-comment">//横向遍历</span><br>            path.add(i);<br>            backtracking(n, k, i + <span class="hljs-number">1</span>);  <span class="hljs-comment">//递归纵向遍历</span><br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//如何剪枝</span><br><span class="hljs-comment">//可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了：i &lt;= n - (k - path.size()) + 1</span><br></code></pre></td></tr></table></figure><p>组合第二题：<a href="https://leetcode.cn/problems/combination-sum-iii/description/">216. 组合总和 III - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>        build(k, n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-comment">//确定终止条件</span><br><br>        <span class="hljs-keyword">if</span> (sum &gt; n) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (path.size() &gt; k) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (sum == n &amp;&amp; path.size() == k) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层搜索的逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>            path.add(i);<br>            sum += i;<br>            build(k, n, i + <span class="hljs-number">1</span>, sum);<br>            sum -= i;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//如何剪枝</span><br><span class="hljs-comment">//已选元素总和如果已经大于n了，那么往后遍历就没有意义，直接剪掉：i &lt;= 9 - (k - path.size()) + 1</span><br></code></pre></td></tr></table></figure><p>组合第三题：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 设置全局列表存储最后的结果</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        <span class="hljs-comment">// 初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串&quot;&quot;</span><br>        String[] numString = &#123; <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span> &#125;;<br>        <span class="hljs-comment">// 迭代处理</span><br>        backTracking(digits, numString, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> list;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuild</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-comment">// 比如digits如果为&quot;23&quot;,num 为0，则str表示2对应的 abc</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(String digits, String[] numString, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 遍历全部一次记录一次得到的字符串</span><br>        <span class="hljs-keyword">if</span> (num == digits.length()) &#123;<br>            list.add(temp.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// str 表示当前num对应的字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> numString[digits.charAt(num) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            temp.append(str.charAt(i));<br>            <span class="hljs-comment">// c</span><br>            backTracking(digits, numString, num + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 剔除末尾的继续尝试</span><br>            temp.deleteCharAt(temp.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合第四题：<a href="https://leetcode.cn/problems/combination-sum/description/">39. 组合总和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(candidates); <span class="hljs-comment">// 先进行排序</span><br>        backtracking(res, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> idx)</span> &#123;<br>        <span class="hljs-comment">// 找到了数字和为 target 的组合</span><br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> idx; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span><br>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target)<br>                <span class="hljs-keyword">break</span>;<br>            path.add(candidates[i]);<br>            backtracking(res, path, candidates, target, sum + candidates[i], i);<br>            path.remove(path.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 回溯，移除路径 path 最后一个元素</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合第五题：<a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>        <span class="hljs-comment">// 加标志数组，用来辅助判断同层节点是否已经遍历</span><br>        Arrays.fill(used, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 为了将重复的数字都放到一起，所以先进行排序</span><br>        Arrays.sort(candidates);<br>        backTracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 出现重复节点，同层的第一个节点已经被访问过，所以直接跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            sum += candidates[i];<br>            path.add(candidates[i]);<br>            <span class="hljs-comment">// 每个节点仅能选择一次，所以从下一位开始</span><br>            backTracking(candidates, target, i + <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>切割第一题：<a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backTracking(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> lists;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-comment">// 如果起始位置大于s的大小，说明找到了一组分割方案</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= s.length()) &#123;<br>            lists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(deque));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 如果是回文子串，则记录</span><br>            <span class="hljs-keyword">if</span> (isPalindrome(s, startIndex, i)) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(startIndex, i + <span class="hljs-number">1</span>);<br>                deque.addLast(str);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 起始位置后移，保证不重复</span><br>            backTracking(s, i + <span class="hljs-number">1</span>);<br>            deque.removeLast();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否是回文串</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex, j = end; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>切割第二题：<a href="https://leetcode.cn/problems/restore-ip-addresses/description/">93. 复原 IP 地址 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() &gt; <span class="hljs-number">12</span>)<br>            <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 算是剪枝了</span><br>        backTrack(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// startIndex: 搜索的起始位置， pointNum:添加逗点的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) &#123;<span class="hljs-comment">// 逗点数量为3时，分隔结束</span><br>            <span class="hljs-comment">// 判断第四段⼦字符串是否合法，如果合法就放进result中</span><br>            <span class="hljs-keyword">if</span> (isValid(s, startIndex, s.length() - <span class="hljs-number">1</span>)) &#123;<br>                result.add(s);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(s, startIndex, i)) &#123;<br>                s = s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.&quot;</span> + s.substring(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 在str的后⾯插⼊⼀个逗点</span><br>                pointNum++;<br>                backTrack(s, i + <span class="hljs-number">2</span>, pointNum);<span class="hljs-comment">// 插⼊逗点之后下⼀个⼦串的起始位置为i+2</span><br>                pointNum--;<span class="hljs-comment">// 回溯</span><br>                s = s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>) + s.substring(i + <span class="hljs-number">2</span>);<span class="hljs-comment">// 回溯删掉逗点</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断字符串s在左闭⼜闭区间[start, end]所组成的数字是否合法</span><br>    <span class="hljs-keyword">private</span> Boolean <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s.charAt(start) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123; <span class="hljs-comment">// 0开头的数字不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) &gt; <span class="hljs-string">&#x27;9&#x27;</span> || s.charAt(i) &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123; <span class="hljs-comment">// 遇到⾮数字字符不合法</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            num = num * <span class="hljs-number">10</span> + (s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) &#123; <span class="hljs-comment">// 如果⼤于255了不合法</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子集第一题：<a href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存放符合条件结果的集合</span><br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 用来存放符合条件结果</span><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        subsetsHelper(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subsetsHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">// 「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」。</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= nums.length) &#123; <span class="hljs-comment">// 终止条件可不加</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            path.add(nums[i]);<br>            subsetsHelper(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子集第二题：<a href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">// 存放符合条件结果的集合</span><br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">// 用来存放符合条件结果</span><br>    <span class="hljs-type">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            result.add(path);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Arrays.sort(nums);<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        subsetsWithDupHelper(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subsetsWithDupHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">if</span> (startIndex &gt;= nums.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            subsetsWithDupHelper(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>排列第一题：<a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491. 非递减子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backTracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() &gt;= <span class="hljs-number">2</span>)<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br><br>        HashSet&lt;Integer&gt; hs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!path.isEmpty() &amp;&amp; path.get(path.size() - <span class="hljs-number">1</span>) &gt; nums[i] || hs.contains(nums[i]))<br>                <span class="hljs-keyword">continue</span>;<br>            hs.add(nums[i]);<br>            path.add(nums[i]);<br>            backTracking(nums, i + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>排列第二题：<a href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">// 存放符合条件结果的集合</span><br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">// 用来存放符合条件结果</span><br>    <span class="hljs-type">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        permuteHelper(nums);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">permuteHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (used[i]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(nums[i]);<br>            permuteHelper(nums);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>排列第三题：<a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 存放结果</span><br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 暂存结果</span><br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        Arrays.fill(used, <span class="hljs-literal">false</span>);<br>        Arrays.sort(nums);<br>        backTrack(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] used)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过</span><br>            <span class="hljs-comment">// 如果同⼀树层nums[i - 1]使⽤过则直接跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果同⼀树⽀nums[i]没使⽤过开始处理</span><br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用</span><br>                path.add(nums[i]);<br>                backTrack(nums, used);<br>                path.remove(path.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">// 回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复</span><br>                used[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 回溯</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>棋盘第一题：<a href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[][] chessboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chessboard) &#123;<br>            Arrays.fill(c, <span class="hljs-string">&#x27;.&#x27;</span>);<br>        &#125;<br>        backTrack(n, <span class="hljs-number">0</span>, chessboard);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">char</span>[][] chessboard)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            res.add(Array2List(chessboard));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; ++col) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(row, col, n, chessboard)) &#123;<br>                chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                backTrack(n, row + <span class="hljs-number">1</span>, chessboard);<br>                chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List <span class="hljs-title function_">Array2List</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chessboard) &#123;<br>            list.add(String.copyValueOf(c));<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span>[][] chessboard)</span> &#123;<br>        <span class="hljs-comment">// 检查列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; ++i) &#123; <span class="hljs-comment">// 相当于剪枝</span><br>            <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查45度对角线</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查135度对角线</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= n - <span class="hljs-number">1</span>; i--, j++) &#123;<br>            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><blockquote><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，</p><p>对于动态规划问题五步曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol></blockquote><p>01背包暴力思路：每个物品只有取或者不取，用回溯算法枚举所有情况，筛选出装满背包的最大价值是多少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><p>01背包动态规划解法：</p><ul><li><code>dp[i][j] </code>表示从下标为<code>[0-i]</code>的物品里任意取，放进容量为j的背包，价值总和最大是多少。</li><li>递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>二叉树</tag>
      
      <tag>回溯</tag>
      
      <tag>递归</tag>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博文</title>
    <link href="/2025/02/19/%E5%8D%9A%E6%96%87/"/>
    <url>/2025/02/19/%E5%8D%9A%E6%96%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是我第一次使用Fluid主题，这篇文章记录了作者不断使用这个主题的收获</p></blockquote><span id="more"></span><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>于今日搭建好博客，现在做一个记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启服务</span><br>hexo server<br><br><span class="hljs-comment"># 新建文章</span><br>hexo new a<br><br><span class="hljs-comment"># 新建草稿</span><br>hexo new draft b<br><br><span class="hljs-comment"># 发布草稿成为文章</span><br>hexo publish b<br><br><span class="hljs-comment"># 普通页面</span><br>hexo new page c<br><br><span class="hljs-comment"># 清空缓存</span><br>hexo clean<br><span class="hljs-comment"># 生成静态文章</span><br>hexo generate 或者是 hexo g<br><span class="hljs-comment"># 部署文章</span><br>hexo deploy 或者是 hexo d<br></code></pre></td></tr></table></figure><p><a href="https://blog.17lai.site/posts/253706ff/">hexo博客博文撰写篇之完美笔记大攻略终极完全版 | 夜法之书</a></p><p>使用hexo new “post-title” 创建一个标题为post-title的md格式的文章</p><p>使用hexo new draft “draft title” 创建一个标题为draft title的草稿文章</p><p>使用hexo new page “page title” 创建一个标题为page title的纯页面</p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><ol><li><pre><code class="language-bash">hexo n &quot;tltile&quot;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-number">2</span>. 在`_post`下的`title`文件夹中放入图片，用markdown引用<br><br>   ~~~markdown<br>   ![加载失败信息](title\xxx.png)<br></code></pre></td></tr></table></figure></code></pre></li></ol><h2 id="文章加封面"><a href="#文章加封面" class="headerlink" title="文章加封面"></a>文章加封面</h2><ol><li><p>在<code>/source/img</code>中放入图片</p></li><li><p>在开头<code>Front-matter</code>中配置 <code>index_img</code> 属性如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">index<span class="hljs-emphasis">_img: [url]</span><br></code></pre></td></tr></table></figure></li><li><p>文章简介</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;这是添加文章的简历，可以让首页文章的展示更加美观<br><span class="hljs-quote">&gt;</span><br><span class="hljs-quote">&lt;!-- more --&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h2><ol><li><p>创建分类页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page categories<br></code></pre></td></tr></table></figure></li><li><p>在<code>source/categories/index.md</code>开头<code>Front-matter</code>中添加<code>type: &quot;categories&quot;</code>如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: categories<br>date: 2022-01-15 21:30:40<br><span class="hljs-section">type: &quot;categories&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure></li><li><p>在博客的头部添加<code>categories: - type</code>即可分类</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: hexo博客搭建<br><span class="hljs-section">categories: [categories1, categories2] </span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><ol><li><p>创建标签页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page tags<br></code></pre></td></tr></table></figure></li><li><p>在<code>source/tags/index.md</code>开头<code>Front-matter</code>中添加<code>type: &quot;tags&quot;</code>如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: categories<br>date: 2022-01-15 21:30:40<br><span class="hljs-section">type: &quot;tags&quot;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure></li><li><p>在博客的头部添加<code>tags: [tag1, tag2, ...]</code>即可分类</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: hexo博客搭建<br><span class="hljs-section">tags: [tag1, tag2] </span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
